# -*- coding: utf-8 -*-
"""collection time

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1vpPBG-hHQhCZG8vgP-l89AySuaa6LB-6
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

df=pd.read_csv('/content/십이지장 췌액 공유 시트 - GI.csv', skiprows=2)
df=df.drop(0, axis=0)

import datetime

df_drop=df[df['채취시간'].notnull()]
df_drop_2 = df_drop.drop(df_drop[df_drop['채취시간'] == '중도탈락'].index)

df_drop_2.shape

def convert_to_minutes(time_str):
  """Converts a string in the format 'x분y초' to minutes.

  Args:
    time_str: The time string in the format 'x분y초'.

  Returns:
    The time in minutes as a float.
  """
  if isinstance(time_str, str): # Check if the input is a string
    try:
      minutes, seconds = time_str.split('분')
      total_minutes = int(minutes) + int(seconds.rstrip('초')) / 60
      return total_minutes
    except ValueError:
      # Handle cases with missing minutes or seconds
      return minutes # or any other default value
  else:
    return 0 # Return 0 for non-string inputs

df_drop_2['채취시간_분'] = df_drop_2['채취시간'].apply(convert_to_minutes)

df_drop_2['채취시간_분'].tail(30)

df_drop_2.columns

df=df_drop_2

df['채취속도_ml/min'] = df['채취 \n용량 [cc]'].astype(float) / df['채취시간_분'].astype(float) # Convert elements to float to handle potential decimals

df['채취속도_ml/min'].head(10)

# Calculate the quartiles and IQR
Q1 = df['채취속도_ml/min'].quantile(0.25)
Q3 = df['채취속도_ml/min'].quantile(0.75)
IQR = Q3 - Q1

# Define bounds for outliers
lower_bound = Q1 - 1.5 * IQR
upper_bound = Q3 + 1.5 * IQR

# Identify outliers
outliers = df[(df['채취속도_ml/min'] < lower_bound) | (df['채취속도_ml/min'] > upper_bound)]

# Create the boxplot
plt.figure(figsize=(10, 6))
sns.boxplot(data=df, x='채취속도_ml/min')

# Annotate outliers with their index
for i in outliers.index:
    plt.annotate(i, (outliers['채취속도_ml/min'].loc[i], 0.1),
                 xytext=(5, 15), textcoords='offset points',
                 arrowprops=dict(arrowstyle='->', connectionstyle='arc3,rad=0.2'))

plt.show()
plt.savefig('boxplot.jpg')

df.shape

# IQR 계산
Q1 = df['채취속도_ml/min'].quantile(0.25)
Q3 = df['채취속도_ml/min'].quantile(0.75)
IQR = Q3 - Q1

# 아웃라이어를 찾기 위한 경계 정의
lower_bound = Q1 - 1.5 * IQR
upper_bound = Q3 + 1.5 * IQR

# 아웃라이어 추출
outliers = df[(df['채취속도_ml/min'] < lower_bound) | (df['채취속도_ml/min'] > upper_bound)]

# 박스플롯 생성
plt.figure(figsize=(10, 6))
sns.boxplot(data=df, x='채취속도_ml/min')

# 아웃라이어에 주석 추가
for i in outliers.index:
    plt.annotate(i,
                 (outliers['채취속도_ml/min'].loc[i], 0),  # 아웃라이어 위치에 주석
                 xytext=(5, 15), textcoords='offset points',  # 주석의 위치 조정
                 arrowprops=dict(arrowstyle='->', connectionstyle='arc3,rad=0.2'))

# 플롯을 화면에 표시하고 저장
plt.show()
plt.savefig('boxplot.jpg')

# IQR 계산
Q1 = df['채취속도_ml/min'].quantile(0.25)
Q3 = df['채취속도_ml/min'].quantile(0.75)
IQR = Q3 - Q1

# 아웃라이어를 찾기 위한 경계 정의
lower_bound = Q1 - 1.5 * IQR
upper_bound = Q3 + 1.5 * IQR

# 아웃라이어 추출
outliers = df[(df['채취속도_ml/min'] < lower_bound) | (df['채취속도_ml/min'] > upper_bound)]

# 아웃라이어를 제외한 데이터프레임 생성
df_drop = df[~((df['채취속도_ml/min'] < lower_bound) | (df['채취속도_ml/min'] > upper_bound))]

# df_drop의 결과 확인
print(df_drop)

sns.boxplot(data=df_drop, x='채취속도_ml/min')

df_drop.shape

sns.histplot(data=df_drop, x='채취속도_ml/min')

sns.scatterplot(data=df_drop, x='채취시간_분', y='분주 후 \n용량 [cc]')

# Convert the problematic columns to string type
df_drop['채취시간_분'] = df_drop['채취시간_분'].astype(str)
df_drop['분주 후 \n용량 [cc]'] = df_drop['분주 후 \n용량 [cc]'].astype(str)

# Create the scatterplot
ax = sns.scatterplot(data=df_drop, x='채취시간_분', y='분주 후 \n용량 [cc]')

# Rotate x-axis labels
plt.xticks(rotation=90)

# Show the plot
plt.show()

# '채취시간_분'을 float 타입으로 변환
df_drop['채취시간_분'] = pd.to_numeric(df_drop['채취시간_분'], errors='coerce')

# '채취시간_분'을 기준으로 오름차순 정렬
df_drop_sorted = df_drop.sort_values(by='채취시간_분')

# 정렬된 DataFrame으로 scatterplot 생성
ax = sns.scatterplot(data=df_drop_sorted, x='채취시간_분', y='분주 후 \n용량 [cc]')

# x축 레이블을 90도 회전
plt.xticks(rotation=90)

# 플롯을 표시
plt.show()

# df.drop 은 aberrant 값 제거한 것임.

# '샘플채취일자'에서 월을 추출
df_drop['채취월'] = pd.to_datetime(df_drop['샘플 \n채취 일자']).dt.month

# 서브플롯을 위한 준비 (월별 데이터 개수가 많지 않으므로 최대 12개의 서브플롯 생성)
months = sorted(df_drop['채취월'].unique())
n_months = len(months)

# 서브플롯 설정 (최대 3행 4열)
fig, axes = plt.subplots(nrows=(n_months // 4) + 1, ncols=min(n_months, 4), figsize=(15, 10))

# 서브플롯에 각 월별 데이터 히스토그램 그리기
for i, month in enumerate(months):
    ax = axes[i // 4, i % 4]  # 서브플롯의 행과 열 선택
    sns.histplot(data=df_drop[df_drop['채취월'] == month], x='채취속도_ml/min', ax=ax)
    ax.set_title(f'{month}월')  # 각 서브플롯의 제목 설정

# 서브플롯 간 간격 조정
plt.tight_layout()

# 그래프 출력
plt.show()

# '샘플채취일자'에서 월을 추출하여 '채취월' 열을 생성
df_drop['채취월'] = pd.to_datetime(df_drop['샘플 \n채취 일자']).dt.month

# 월별로 '채취속도_ml/min'에 대한 요약 통계 계산
monthly_stats = df_drop.groupby('채취월')['채취속도_ml/min'].describe()

# 결과 출력
print(monthly_stats)

df_6789 = df_drop[df_drop['채취월'].isin([6, 7, 8, 9])]
# df_6789는 6월~9월 데이터만 따로 모은 것

df_6789.columns

sns.regplot(x='채취시간_분', y='분주 후 \n용량 [cc]', data=df_6789)
plt.show()

# Convert the columns to numeric type. Errors='coerce' will replace invalid parsing with NaN
df_6789['채취시간_분'] = pd.to_numeric(df_6789['채취시간_분'], errors='coerce')
df_6789['분주 후 \n용량 [cc]'] = pd.to_numeric(df_6789['분주 후 \n용량 [cc]'], errors='coerce')

# Create the regression plot
sns.regplot(x='채취시간_분', y='분주 후 \n용량 [cc]', data=df_6789)
plt.show()

import statsmodels.api as sm
import pandas as pd
from statsmodels.stats.stattools import durbin_watson

# Use df_6789 which has been cleaned and converted to numeric
X = df_6789['채취시간_분']  # 독립 변수
y = df_6789['분주 후 \n용량 [cc]']  # 종속 변수

# Check for missing values and drop rows with NaN
df_clean = df_6789.dropna(subset=['채취시간_분', '분주 후 \n용량 [cc]'])

# Check for constant variance
if df_clean['채취시간_분'].nunique() <= 1:
    print("Independent variable is constant. Cannot calculate Durbin-Watson.")
else:
    X = df_clean['채취시간_분']
    y = df_clean['분주 후 \n용량 [cc]']

    # 상수항 추가 (Intercept)
    X = sm.add_constant(X)

    # OLS 모델 적합
    model = sm.OLS(y, X).fit()

    # 잔차 계산
    residuals = model.resid

    # Durbin-Watson 통계량 계산
    dw = durbin_watson(residuals)

    # 결과 출력
    print(f'Durbin-Watson 통계량: {dw}')

plt.scatter(model.fittedvalues, residuals)
plt.axhline(y=0, color='r', linestyle='--')
plt.xlabel('예측값')
plt.ylabel('잔차')
plt.title('잔차 vs 예측값')
plt.show()

import scipy.stats as stats

# Q-Q Plot
stats.probplot(residuals, dist="norm", plot=plt)
plt.title('Q-Q Plot')
plt.show()

# 독립변수와 종속변수 설정
X = df_clean['채취시간_분']  # 독립 변수
y = df_clean['분주 후 \n용량 [cc]']  # 종속 변수

# 상수항 추가 (Intercept)
X = sm.add_constant(X)

# OLS 모델 적합
model = sm.OLS(y, X).fit()

# 모델 요약 출력
print(model.summary())

# 잔차 계산
residuals = model.resid

# Durbin-Watson 통계량 계산
from statsmodels.stats.stattools import durbin_watson
dw = durbin_watson(residuals)

# 결과 출력
print(f'Durbin-Watson 통계량: {dw}')

0.5/0.0629

#calculate CUSUM

# Set the target (mean value)
target = 0.2/7.9

# Initialize CUSUM arrays for upper and lower CUSUMs
cusum_pos = np.zeros(len(df_drop['채취속도_ml/min']))  # Positive CUSUM (Upper)
cusum_neg = np.zeros(len(df_drop['채취속도_ml/min']))  # Negative CUSUM (Lower)

# Define the threshold
K = 0.13562601238647637/2  # Sensitivity factor, often set to half the standard deviation of the data
# Access the values in the '채취속도_ml/min' column
values = df_drop['채취속도_ml/min'].values

# Loop through data to calculate CUSUM values
for i in range(1, len(values)):
    cusum_pos[i] = max(0, cusum_pos[i-1] + values[i] - (target + K))  # Upper CUSUM
    cusum_neg[i] = max(0, cusum_neg[i-1] + (target - K) - values[i])  # Lower CUSUM

# Plot the data
plt.figure(figsize=(10, 6))
plt.plot(values, label='Data', marker='o')
plt.plot(cusum_pos, label='CUSUM Upper', marker='o', color='green')
plt.plot(cusum_neg, label='CUSUM Lower', marker='o', color='red')

# Add labels and title
plt.title('CUSUM Control Chart')
plt.xlabel('Observation')
plt.ylabel('Cumulative Sum')
plt.axhline(0, color='black', lw=1)
plt.legend()
plt.grid(True)
plt.show()

# Calculate the standard deviation of the '채취속도_ml/min' column
std_dev = df_drop['채취속도_ml/min'].std()

# Print the result
print(f"Standard deviation of 채취속도_ml/min: {std_dev}")

